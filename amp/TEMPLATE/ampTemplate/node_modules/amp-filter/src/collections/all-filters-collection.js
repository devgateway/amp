var Backbone = require('backbone');
var _ = require('underscore');
var $ = require('jquery');

var GenericFilterModel = require('../models/generic-filter-model');
var OrgRoleFilterModel = require('../models/org-role-filter-model');
var YearsFilterModel = require('../models/years-filter-model');
var YearsOnlyFilterModel = require('../models/years-only-filter-model');


//TODO: move most code from filters-view here.
module.exports = Backbone.Collection.extend({
  url: '/rest/filters',
  _loaded: null,
  _allDeferreds: [],
   componentCaller: null,
  initialize: function(models,options) {
    this.on('add', this._cleanUpAfterAdd);
    this.load();
    if (options.caller) {
    	componentCaller = options.caller;
    }
  },

  load: function() {
    var self = this;
    if(!this._loaded){
      this._loaded = new $.Deferred();
      this.fetch({remove: false}).then(function() {
        // when all child calls are done resolve.
        $.when.apply($, self._allDeferreds)
          .done(self._loaded.resolve)
          .fail(self._loaded.reject);
      }).fail(self._loaded.reject);
    }

    return this._loaded;
  },

  _cleanUpAfterAdd: function(model) {
    var self = this;
    // remove if ui false also catches empty dummy filters we add in 'model' function below.
    if (!model.get('ui')) {
      self.remove(model);
    }
    //remove if the endpoint returns the filter type (dashboard,tabs,reports and/or GIS) for which
    //the model should be visible and the caller is not of the same tpe
    
    if (model.get('filterType')) {
    	var isOfRequiredType = _.some( model.get('filterType'), function( type ) {
    	    return type === componentCaller || type === "ALL";
    	});
    	
    	if (!isOfRequiredType) {
    		self.remove (model);
    	}
    }
    // Expose this field for later usage.
    this.componentCaller = componentCaller;
  },


  parse: function(data) {
    //only keep filters with ui == true;
    data = _.filter(data, function(obj) {
      return obj.ui;
    });

    //remove org, sector EPs
    data = _.filter(data, function(obj) {
      return (obj.endpoint !== '/rest/filters/org-groups' &&
        obj.endpoint !== '/rest/filters/org-types' &&
        obj.endpoint !== '/rest/filters/org-roles' &&
        obj.endpoint !== '/rest/filters/orgs' &&
        obj.endpoint !== '/rest/filters/programs' &&        
        obj.endpoint !== '/rest/filters/sectors');  
    });

    return data;
  },
  
  model: function(attrs, options) {
    var tmpModel = null;
    var self = options.collection;
    // switch for model polymorphism.
    switch (attrs.id) {
      case 'ProgramList':
      case 'SectorList':
      case 'Orgs':
       self._allDeferreds.push(self._buildTreeImplementation(self, attrs));
       tmpModel = new Backbone.Model({ui:false});
      break;
      default:    	  
    	  if (attrs.id == 'date' || (attrs.id.indexOf('-date') != -1 ) || (attrs.id.indexOf('date-') != -1 )) {
    		  tmpModel = new YearsFilterModel(attrs);  // hacky but less hacky than enumerating them. Long term solution -> the endpoint should return a field telling the type of a field
    	  } else if (attrs.id == 'computed-year') {
    		  tmpModel = new YearsOnlyFilterModel(attrs);
    	  } else {
    		  tmpModel = new GenericFilterModel(attrs);
    		  self._allDeferreds.push(tmpModel.getTree());
    	  }
    }

    return tmpModel;
  },

  // get endpoint's children and load them into self...
  _goOneDeeper: function(self, attrs) {
    var url = attrs.endpoint;
    var deferred = $.Deferred();
    var tmpDeferreds = [];

    var tmpCollection = new Backbone.Collection();
    tmpCollection.url = url;
    tmpCollection.fetch().then(function(data) {
      _.each(data, function(APIFilter) {
        var tmpModel = new GenericFilterModel({
          url: url + '/' + APIFilter.id,
          name: APIFilter.name,
          tab: APIFilter.tab,
          ui: true,
          group: attrs.id,
          empty: false
        });
        self.add(tmpModel);
        tmpDeferreds.push(tmpModel.getTree());
      });

      if (_.isEmpty(data)) {
        console.warn('Filters API returned empty', url);
        // Create empty model so the view doesnt fail.
        var tmpModel = new GenericFilterModel({
            url: url,
            name: attrs.name,
            ui: true,
            group: attrs.id,
            empty: true
          });
          self.add(tmpModel);
          tmpDeferreds.push(tmpModel.getTree());
      }
      
      $.when.apply($, tmpDeferreds).then(function() {
          deferred.resolve();
        });

    });

    return deferred;
  },
  _getGroup: function(definition, attrs) {
	  var group = definition.name;
	  if (attrs.id === 'Orgs' && definition.name != 'Donor') {
		  group = 'Role';
	  }
	  
	  if (attrs.id === 'SectorList') {
		  group = 'Sectors';
	  }
	  
	  if (attrs.id === 'ProgramList') {
		  group = 'Programs';
	  }
	  
	  return group;
   },
  _buildTreeImplementation: function(self, attrs) {
	    var url = attrs.endpoint;
	    var deferred = $.Deferred();
	    var tmpDeferreds = [];
	    var self = this; 	   
	    
	    $.get(url, function( data ) {      
           var listDefinitions = data.listDefinitions;                    
          _.each(listDefinitions, function(def) {          	  
        	  var items = data.items[def.items];         	   
        	  var tree = self._createTree(items, def);        	  
        	  var tmpModel = new GenericFilterModel({
        	      id: def.id,        	    
                  data: tree,
                  name: def.name,
                  tab: def.tab,
                  ui: true,
                  group: self._getGroup(def, attrs),
                  empty: false
                });
        	  
        	        	  
        	    self.add(tmpModel);                
                tmpDeferreds.push(tmpModel.getTree());                    
          });    
          
          $.when.apply($, tmpDeferreds).then(function() {
              deferred.resolve();
            });
        });
	    
	    return deferred;
	  },

	  _createTree: function(data, definition) {
		  var dataCopy = JSON.parse(JSON.stringify(data));
		  var tree = [];	  
		  _.each(dataCopy, function(level1) {
			  var level1 = $.extend({}, level1);
			  level1.filterId = definition.filterIds[0];
			  if (level1.children && level1.children.length > 0) {
				  
				  level1.children = level1.children.filter(function(item) {
					  if (item.listDefinitionIds) {
						  return item.listDefinitionIds.includes(definition.id)
					  } else {
						   return true; 
					  }
					  
				  }).map(function(item) {
					  item.filterId = definition.filterIds[1];
					  return item;
				  });
				  
				  _.each(level1.children, function(level2) {
					  if (level2.children && level2.children.length > 0) {
						  level2.children = level2.children.filter(function(item) {
							  if (item.listDefinitionIds) {
								  return item.listDefinitionIds.includes(definition.id);
							  }
							  return true;							  
						  }).map(function(item) {
							  item.filterId = definition.filterIds[2];
							  return item;
						  });
					  }
					  
				  })
			  }
			  
			  tree.push(level1);			  
		   });
          
		  return tree;
	  },

});
