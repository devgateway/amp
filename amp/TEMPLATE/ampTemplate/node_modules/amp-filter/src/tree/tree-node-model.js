var _ = require('underscore');
var Backbone = require('backbone');
var TreeNodeModel; // declare here to help with ref loop of collection and model
var TreeNodeCollection = Backbone.Collection.extend({  model:TreeNodeModel });

//TODO: propagation bug if mid level node is half filled and you 'deselect all' it won't propogate to children.

TreeNodeModel = Backbone.Model.extend({
  defaults:{
    selected: undefined,  // default is selected. change to string / ternary, for off, semi, and on
    expanded: true,
    visible: true,
    numSelected: 0,
    numPossible: 0,
    children: null,     // type TreeNodeCollection
    isSelectable: false  // is this node itself selectable (ie. should it have an 'unkown' child)
  },

  initialize:function(obj) {
    var self = this;
    var childrenCollection = new TreeNodeCollection();
    this.set('children', childrenCollection);
    
    /* TODO-CONSTANTIN: temporary comment until I am finished learning Filters frontend 
     console.log("building a tree node model for: " + JSON.stringify(obj));
     */
    
    //iterate over children
    if (Array.isArray(obj.children)) {
      _.each(obj.children, function(child) {
        var newChild = new TreeNodeModel(child);
        childrenCollection.add(newChild);
      });
    }

    // if we have children, then add self as a leaf node, 'unkown'
    if (!childrenCollection.isEmpty() &&  this.get('isSelectable')) {
      var unkownNode = new TreeNodeModel(self.toJSON());
      unkownNode.set('name', 'unkown: ' + this.get('name'));
      childrenCollection.add(unkownNode);
    }

    this._addListenersToChildren();

    this.on('change:selected', self._onSelectChange);

    this._updateCount();
  },


// merge based on filterId as we serialize....
// options.wholeModel returns whole Models instead of just ids
// options.includeUnselected returns full tree, even if nodes are not selected.
// Code explicitly ignores Donor Group,Donor Type and the rest of the organizations.
//   they only have FilterIds for deserialize for backwards compatibility.
// TODO: consider pulling out options.includeUnselected into its own function getAllFilters()
serialize: function(options) {
	  var tmpSerialized = {};
	  var children = this.get('children');

    /**
	        
	     
	  +--^----------,--------,-----,--------^-,
	  | |||||||||   `--------'     |          O
	  `+---------------------------^----------|
	    `\_,---------,---------,--------------'
	      / XXXXXX /'|       /'
	     / XXXXXX /  `\    /'                      TO INVESTIGATE: why is this function called for 4 times (!!!) per each item when pressing "apply"?
	    / XXXXXX /`-------'
	   / XXXXXX /
	  / XXXXXX /
	 (________(                
	   
	    
	// 
	//    if ((this.get('name')== 'Yes') || (this.get('name') == 'No') || (this.get('name') == 'All') || this.get('name') == 'Humanitarian Aid' || this.get('name') == 'Disaster Response Marker') {
	//    	console.log('serializing node with name ' + this.get('name') + ", selected: " + this.get('selected'));
	//
	//    	debugger;
	//    }
	*/
    
    if (options.includeUnselected) {
    	if (this.get('filterId') && this.get('filterId') !== 'Donor Group' && this.get('filterId') !== 'Donor Type' 
    		&& this.get('filterId') !== 'Implementing Agency' && this.get('filterId') !== 'Beneficiary Agency' && this.get('filterId') !== 'Executing Agency' && this.get('filterId') !== 'Responsible Organization') {
    			tmpSerialized[this.get('filterId')] = (options.wholeModel? [this]:[this.id]);
    	} else{
    		tmpSerialized.unassigned = (options.wholeModel? [this]:[this.id]);
    	}
    	this._serializeChildren(tmpSerialized, children, options);
    } else {
    	if (children.length > 0) {
    		// If all children are selected, and we have our own filterId, then just use our id, don't recurse.
    		if (this.get('numSelected') >= this.get('numPossible') && this.get('filterId') && this.get('filterId') !== 'Donor Group' && this.get('filterId') !== 'Donor Type' 
    			&& this.get('filterId') !== 'Implementing Agency' && this.get('filterId') !== 'Beneficiary Agency' && this.get('filterId') !== 'Executing Agency' && this.get('filterId') !== 'Responsible Organization') {
    				tmpSerialized[this.get('filterId')] = (options.wholeModel? [this]:[this.id]);
    		} else {
    			this._serializeChildren(tmpSerialized, children, options);
    		}
      } else {
    	  //no children so just return self.
    	  if (this.get('selected')) {
    		  if (this.get('filterId') && this.get('filterId') !== 'Donor Group' && this.get('filterId') !== 'Donor Type' 
    			  && this.get('filterId') !== 'Implementing Agency' && this.get('filterId') !== 'Beneficiary Agency' && this.get('filterId') !== 'Executing Agency' && this.get('filterId') !== 'Responsible Organization') {
    			  	tmpSerialized[this.get('filterId')] = (options.wholeModel? [this]:[this.id]);
    		  } else {
    			  tmpSerialized.unassigned = (options.wholeModel? [this]:[this.id]);
    		  }
    	  }
      }
   }
   this._mergeUnassigned(tmpSerialized);
   return tmpSerialized;
},

  _serializeChildren: function(tmpSerialized, children, options){
    children.each(function(child) {
      var serializedChild = child.serialize(options);
      _.each(serializedChild, function(v,k){
        if(v){
          //merge if key exists
          if (tmpSerialized[k]) {
            tmpSerialized[k] = tmpSerialized[k].concat(v);
          } else {
            tmpSerialized[k] = v;
          }
        }
      });
    });
  },

  _mergeUnassigned: function(tmpSerialized){
    // if current node has a filterId put all 'unassigned' elements under this.
    if(this.get('filterId')){
      var filterId = this.get('filterId');
      if(tmpSerialized[filterId] && tmpSerialized.unassigned){
        tmpSerialized[filterId] = tmpSerialized[filterId].concat(tmpSerialized.unassigned);
        delete tmpSerialized.unassigned;
      } else if (tmpSerialized.unassigned){
        tmpSerialized[filterId] = tmpSerialized.unassigned;
        delete tmpSerialized.unassigned;
      }
    }
  },

  deserialize: function(blob) {
    var self = this;
    var children = this.get('children');
    if (children.length > 0) {
      children.each(function(child) {
        if(!child.get('filterId') && self.get('filterId')){
          child.set('filterId', self.get('filterId'));
        }
        child.deserialize(blob);
      });
    }

    if(blob[this.get('filterId')]){
      if (_(blob[this.get('filterId')]).indexOf(this.id) > -1) {
        this.set('selected', true, {propagation: true});
      } else if (children.length === 0) {
        this.set('selected', false, {propagation: true});
      }
    }
  },


  _onSelectChange:function(model, argument, options) {
    var self = this;
    var children = this.get('children');

    if (this.get('selected')) {
      this.set('numSelected', this.get('numPossible'));
    } else {
      this.set('numSelected', 0);
    }

    if (!children.isEmpty()) {
      self._updateChildNodes(options.propagation);
    }

    if (options.propagation) {
      self.trigger('updateCount');
    }
  },


  _addListenersToChildren:function() {
    var self = this;
    var children = this.get('children');
    children.each(function(child) {
      child.on('change:visible', function() {
        // If no children are visible, then hide self.
        if (!children.findWhere({visible: true})) {
          self.set({visible: false});
        } else {
          self.set({visible: true});
        }
      });
      child.on('updateCount', function() {
        self._updateCount();
        self.trigger('updateCount');
      });
    });
  },

  _updateCount:function() {
    var children = this.get('children');
    var countTotal = {
      selected: 0,
      possible:0
    };

    if (!children.isEmpty()) {
      children.each(function(child) {
        countTotal.selected += child.get('numSelected');
        countTotal.possible += child.get('numPossible');
      });
    } else {
      countTotal = {
        selected: (this.get('selected') ? 1 : 0),
        possible: 1
      };
    }

    this.set('numSelected', countTotal.selected);
    this.set('numPossible', countTotal.possible);
  },

  _updateChildNodes:function(propagation) {
    var self = this;
    var children = this.get('children');

    if (!children.isEmpty()) {
      children.each(function(child) {
        child.set('selected', self.get('selected'), {propagation: propagation});
      });
    }
  },

  filterText: function(txt) {
    var children = this.get('children');

    if (!children.isEmpty()) {
      // if the node itself matches, turn it on, even if no children are visible.
      if (this.get('name') && this.get('name').toLowerCase().indexOf(txt) > -1) {
        this.set('visible', true);
      }

      // FYI: putting inside an else above keeps children visible if parent matches.
      children.each(function(child) {
        child.filterText(txt);
      });

    } else {
      if (this.get('name') && this.get('name').toLowerCase().indexOf(txt) > -1) {
        this.set('visible', true);
      } else {
        this.set('visible', false);
      }
    }
  }

});


module.exports = TreeNodeModel;
