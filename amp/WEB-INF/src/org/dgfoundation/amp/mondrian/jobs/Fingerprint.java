package org.dgfoundation.amp.mondrian.jobs;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.apache.log4j.Logger;
import org.dgfoundation.amp.ar.viewfetcher.SQLUtils;
import org.dgfoundation.amp.mondrian.ExceptionRunnable;
import org.dgfoundation.amp.mondrian.MondrianETL;
import org.dgfoundation.amp.mondrian.monet.MonetConnection;

import com.google.common.base.Predicate;

import clover.com.google.common.base.Joiner;

/**
 * an EtlJob which takes the "run or not run" decision based on fingerprints generated by SQL queries interrogating Postgres and storing the results in Monet
 * 
 * @author Constantin Dolghier
 *
 */
public class Fingerprint {
	
	public final static String FINGERPRINT_TABLE = "etl_fingerprints";
	
	public final String keyName;
	public final List<String> fingerprintQueries;
	
	protected static Logger logger = Logger.getLogger(Fingerprint.class);
	
	public Fingerprint(String keyName, List<String> fingerprintQueries) {
		this.keyName = keyName;
		this.fingerprintQueries = Collections.unmodifiableList(new ArrayList<>(fingerprintQueries));
	}
	
	
	/**
	 * compares fingerprint stored in Monet with computed fingerprint
	 * @return
	 * @throws SQLException
	 */
	public boolean changesDetected(Connection postgresConn, MonetConnection monetConn) throws SQLException {
		String currentFingerprint = computeFingerprint(postgresConn);
		String etlFingerprint = readMonetFingerprint(monetConn);
		boolean res = !currentFingerprint.equals(etlFingerprint);
		//logger.error(String.format("fingerprinting %s: stored FP = %s, present FP = %s, needs refresh: %s", keyName, etlFingerprint, currentFingerprint, res));
		return res;
	}
	
	/**
	 * returns a ';'-delimited list of hashes returned by psql queries
	 * @return
	 */
	protected String computeFingerprint(Connection postgresConn) {
		List<String> fps = new ArrayList<>();
		for (String query:fingerprintQueries) {
			List<String> fp = SQLUtils.fetchAsList(postgresConn, query, 1);
			fps.add(Joiner.on(',').join(fp));
		}
		return Joiner.on(';').join(fps);
	}
	
	/**
	 * computes the current fingerprint and serializes it
	 * @throws SQLException
	 */
	public void saveFingerprint(Connection postgresConn, MonetConnection monetConn) throws SQLException {
		readOrCreateDefaultFingerprint(monetConn);
		serializeFingerprint(monetConn, computeFingerprint(postgresConn));
	}
	
	/**
	 * <strong>assumes</b> that the fingerprints table exists
	 * @param fp
	 */
	protected void serializeFingerprint(MonetConnection monetConn, String fp) {
		monetConn.executeQuery(String.format("DELETE FROM %s where key='%s'", FINGERPRINT_TABLE, keyName));
		monetConn.executeQuery(String.format("INSERT INTO %s(key,value) VALUES ('%s', '%s')", FINGERPRINT_TABLE, keyName, fp));		
	}
	
	/**
	 * extracts the currently-stored fingerprint. If none exists, returns a dummy value
	 * @return
	 * @throws SQLException
	 */
	protected String readMonetFingerprint(MonetConnection monetConn) throws SQLException {
		return readOrCreateDefaultFingerprint(monetConn);
	}
	
	/**
	 * invariant: after function exit, the fingerprint table will exist in the db
	 * @return
	 */
	protected String readOrCreateDefaultFingerprint(MonetConnection monetConn) {
		if (!monetConn.tableExists(FINGERPRINT_TABLE)) {
			monetConn.executeQuery(String.format("CREATE TABLE %s (key %s, value %s)", FINGERPRINT_TABLE,
					MonetConnection.getMapper().mapSqlTypeToName(java.sql.Types.VARCHAR), MonetConnection.getMapper().mapSqlTypeToName(java.sql.Types.LONGVARCHAR)));
			monetConn.flush();
		}
		
		List<?> hashes = SQLUtils.fetchAsList(monetConn.conn, String.format("SELECT value FROM %s WHERE key='%s'", FINGERPRINT_TABLE, keyName), 1);
		switch(hashes.size()) {
			case 0: {
				String defaultHash = String.format("defaultHash_%s_%d", keyName, System.currentTimeMillis());
				//serializeFingerprint(defaultHash);
				return defaultHash;
			}
				
			case 1: return nullOrString(hashes.get(0));
				
			default:
				throw new RuntimeException("multiple values found for the hashkey " + keyName + " in the fingerprints storage");
		}
	}
	
	public static String nullOrString(Object obj) {
		if (obj == null)
			return null;
		return obj.toString();		
	}
	
	public void runIfFingerprintChanged(Connection postgresConn, MonetConnection monetConn, Predicate<Fingerprint> onNothingChanged, ExceptionRunnable<SQLException> r) throws SQLException {
		if (changesDetected(postgresConn, monetConn)) {
			r.run();
			saveFingerprint(postgresConn, monetConn);
			return;
		}
		
		if (onNothingChanged != null)
			onNothingChanged.apply(this);
	}
	
	@Override public String toString() {
		return this.keyName;
	}
	
	public static String buildTableHashingQuery(String table) {
		return String.format("select md5(cast((array_agg(%s)) AS text)) from %s", table, table);
	}
	
	public static String buildTranslationHashingQuery(Class<?> clazz) {
		return String.format(
			"select md5(coalesce(cast((array_agg(t.field_name || t.locale || t.object_id || t.translation)) AS text), 'nothing')) from " + 
					"(select * from amp_content_translation where object_class = '%s' order by object_id, field_name, locale) t",
					clazz.getName()
				);
	}
}
