package org.dgfoundation.amp.nireports.amp;

import org.dgfoundation.amp.ar.viewfetcher.SQLUtils;
import org.dgfoundation.amp.nireports.Cell;
import org.dgfoundation.amp.nireports.NiReportsEngine;
import org.dgfoundation.amp.nireports.NiUtils;
import org.dgfoundation.amp.nireports.schema.Behaviour;
import org.dgfoundation.amp.nireports.schema.NiDimension;
import org.dgfoundation.amp.nireports.schema.SqlSourcedColumn;
import org.digijava.kernel.translator.LocalizableLabel;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;


/**
 * a {@link SqlSourcedColumn} which uses AMP's PostgreSQL infrastructure as a source of data
 * @author Dolghier Constantin
 *
 */
public abstract class PsqlSourcedColumn<K extends Cell> extends SqlSourcedColumn<K> {
    
    final LinkedHashSet<String> viewColumns;

    /**
     * Specifies the FM feature under which this column is grouped
     * introduced for MTEFs -- so that there is an FM entry when MTEF columns are autogenerated
     * and added to amp_columns
     */
    protected String group = null;

    public PsqlSourcedColumn(String columnName, NiDimension.LevelColumn levelColumn, String viewName, Behaviour<?> behaviour) {
        this(columnName, new LocalizableLabel(columnName), levelColumn, viewName, behaviour);
    }

    public PsqlSourcedColumn(String columnName, LocalizableLabel label, NiDimension.LevelColumn levelColumn, String viewName, Behaviour<?> behaviour) {
        super(columnName, label, levelColumn, viewName, keyColumnName(viewName, "amp_activity_id"), behaviour, AmpReportsSchema.columnDescriptions.get(columnName));
        this.viewColumns = SQLUtils.getTableColumns(viewName);
        check();
    }
    
    public static String keyColumnName(String viewName, String defaultValue) {
        Set<String> cols = SQLUtils.getTableColumns(viewName);
        return cols.isEmpty() ? defaultValue : cols.iterator().next();
    }
    
    public String getGroup() {
        return this.group;
    }
    
    public PsqlSourcedColumn<K> withGroup(String group) {
        this.group = group;
        return this;
    }
    
    /**
     * utility function to check 
     * @param col
     */
    protected void check() {
            NiUtils.failIf(viewColumns.isEmpty(), String.format("column %s: view %s does not exist", name, viewName));
            NiUtils.failIf(!viewColumns.contains(mainColumn), String.format("column %s: view %s does not have mainColumn %s", name, viewName, mainColumn));

    }

    protected Map<NiDimension.NiDimensionUsage, NiDimension.Coordinate> buildCoordinates(long entityId,
            NiReportsEngine engine, ResultSet rs) throws SQLException {
        HashMap<NiDimension.NiDimensionUsage, NiDimension.Coordinate> coos = new HashMap<>();

        levelColumn.ifPresent(column -> coos.put(column.dimensionUsage, column.getCoordinate(entityId)));

        addSubActivityCoordinates(coos, engine, rs);

        return coos;
    }

    protected void addSubActivityCoordinates(Map<NiDimension.NiDimensionUsage, NiDimension.Coordinate> coos,
            NiReportsEngine engine, ResultSet rs) throws SQLException {
        Map<String, NiDimension.LevelColumn> levelColumns = engine.schema.getSubDimensions().getLevelColumns();
        for (Map.Entry<String, NiDimension.LevelColumn> optDim : levelColumns.entrySet()) {
            if (viewColumns.contains(optDim.getKey())) {
                addCoordinateIfLongExists(coos, rs, optDim.getKey(), optDim.getValue());
            }
        }
    }
}
