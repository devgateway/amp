import { useMemo, createElement } from 'react';
import { animated, useSpring, useTransition, to } from '@react-spring/web';
import { useTheme, useMotionConfig, positionFromAngle, degreesToRadians, normalizeAngle } from '@nivo/core';
import { getScaleTicks } from '@nivo/scales';
import { ArcLine } from '@nivo/arcs';
import { jsxs, jsx, Fragment } from 'react/jsx-runtime';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}

var CircularAxisTick = function CircularAxisTick(_ref) {
  var label = _ref.label,
      animatedProps = _ref.animated;
  var theme = useTheme();
  return jsxs(animated.g, {
    opacity: animatedProps.opacity,
    children: [jsx(animated.line, {
      x1: animatedProps.x1,
      y1: animatedProps.y1,
      x2: animatedProps.x2,
      y2: animatedProps.y2,
      style: theme.axis.ticks.line
    }), jsx(animated.text, {
      dx: animatedProps.textX,
      dy: animatedProps.textY,
      dominantBaseline: "central",
      style: theme.axis.ticks.text,
      textAnchor: "middle",
      children: label
    })]
  });
};

var getLinePositions = function getLinePositions(angle, innerRadius, outerRadius) {
  var start = positionFromAngle(degreesToRadians(angle), innerRadius);
  var end = positionFromAngle(degreesToRadians(angle), outerRadius);
  return {
    x1: start.x,
    y1: start.y,
    x2: end.x,
    y2: end.y
  };
};

var getTextPosition = function getTextPosition(angle, radius) {
  var position = positionFromAngle(degreesToRadians(angle), radius);
  return {
    textX: position.x,
    textY: position.y
  };
};

var CircularAxis = function CircularAxis(_ref) {
  var type = _ref.type,
      _ref$center = _ref.center,
      center = _ref$center === void 0 ? [0, 0] : _ref$center,
      radius = _ref.radius,
      originalStartAngle = _ref.startAngle,
      originalEndAngle = _ref.endAngle,
      scale = _ref.scale,
      _ref$tickSize = _ref.tickSize,
      tickSize = _ref$tickSize === void 0 ? 5 : _ref$tickSize,
      _ref$tickPadding = _ref.tickPadding,
      tickPadding = _ref$tickPadding === void 0 ? 12 : _ref$tickPadding,
      _ref$tickComponent = _ref.tickComponent,
      tickComponent = _ref$tickComponent === void 0 ? CircularAxisTick : _ref$tickComponent;
  var startAngle = originalStartAngle - 90;
  var endAngle = originalEndAngle - 90;
  var theme = useTheme();

  var _useMotionConfig = useMotionConfig(),
      animate = _useMotionConfig.animate,
      springConfig = _useMotionConfig.config;

  var spring = useSpring({
    radius: radius,
    startAngle: startAngle,
    endAngle: endAngle,
    opacity: 1,
    immediate: !animate,
    config: springConfig
  });
  var ticks = useMemo(function () {
    var values = getScaleTicks(scale);
    return values.map(function (value, index) {
      return {
        key: index,
        label: value,
        angle: scale(value) - 90
      };
    });
  }, [scale]);
  var outerRadius = type === 'inner' ? radius - tickSize : radius + tickSize;
  var textRadius = type === 'inner' ? outerRadius - tickPadding : outerRadius + tickPadding;
  var transition = useTransition(ticks, {
    keys: function keys(tick) {
      return tick.key;
    },
    initial: function initial(tick) {
      return _objectSpread2(_objectSpread2(_objectSpread2({}, getLinePositions(tick.angle, radius, outerRadius)), getTextPosition(tick.angle, textRadius)), {}, {
        opacity: 1
      });
    },
    from: function from(tick) {
      return _objectSpread2(_objectSpread2(_objectSpread2({}, getLinePositions(tick.angle, radius, outerRadius)), getTextPosition(tick.angle, textRadius)), {}, {
        opacity: 0
      });
    },
    enter: function enter(tick) {
      return _objectSpread2(_objectSpread2(_objectSpread2({}, getLinePositions(tick.angle, radius, outerRadius)), getTextPosition(tick.angle, textRadius)), {}, {
        opacity: 1
      });
    },
    update: function update(tick) {
      return _objectSpread2(_objectSpread2(_objectSpread2({}, getLinePositions(tick.angle, radius, outerRadius)), getTextPosition(tick.angle, textRadius)), {}, {
        opacity: 1
      });
    },
    leave: function leave(tick) {
      return _objectSpread2(_objectSpread2(_objectSpread2({}, getLinePositions(tick.angle, radius, outerRadius)), getTextPosition(tick.angle, textRadius)), {}, {
        opacity: 0
      });
    },
    immediate: !animate,
    config: springConfig
  });
  return jsxs("g", {
    transform: "translate(".concat(center[0], ", ").concat(center[1], ")"),
    children: [jsx(ArcLine, _objectSpread2(_objectSpread2({
      animated: spring
    }, theme.axis.domain.line), {}, {
      fill: "none"
    })), transition(function (animatedProps, tick) {
      return createElement(tickComponent, {
        key: tick.key,
        label: tick.label,
        animated: animatedProps
      });
    })]
  });
};

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

var RadialGrid = function RadialGrid(_ref) {
  var scale = _ref.scale,
      innerRadius = _ref.innerRadius,
      outerRadius = _ref.outerRadius;
  var theme = useTheme();
  var angles = useMemo(function () {
    var values = getScaleTicks(scale);
    return values.map(function (angleValue, index) {
      return {
        id: index,
        angle: scale(angleValue) - 90
      };
    });
  }, [scale]);

  var _useMotionConfig = useMotionConfig(),
      animate = _useMotionConfig.animate,
      springConfig = _useMotionConfig.config;

  var transition = useTransition(angles, {
    keys: function keys(item) {
      return item.id;
    },
    initial: function initial(item) {
      return {
        angle: item.angle,
        opacity: 1
      };
    },
    from: function from(item) {
      return {
        angle: item.angle,
        opacity: 0
      };
    },
    enter: function enter(item) {
      return {
        angle: item.angle,
        opacity: 1
      };
    },
    update: function update(item) {
      return {
        angle: item.angle,
        opacity: 1
      };
    },
    leave: function leave(item) {
      return {
        angle: item.angle,
        opacity: 0
      };
    },
    config: springConfig,
    immediate: !animate
  });
  return jsx(Fragment, {
    children: transition(function (style, angle) {
      return jsx(animated.g, {
        transform: style.angle.to(function (v) {
          return "rotate(".concat(v, ")");
        }),
        opacity: style.opacity,
        children: jsx("line", _objectSpread2({
          x1: innerRadius,
          x2: outerRadius
        }, theme.grid.line))
      }, angle.id);
    })
  });
};

var CircularGrid = function CircularGrid(_ref) {
  var scale = _ref.scale,
      originalStartAngle = _ref.startAngle,
      originalEndAngle = _ref.endAngle;
  var theme = useTheme();
  var startAngle = originalStartAngle - 90;
  var endAngle = originalEndAngle - 90;
  var radii = useMemo(function () {
    var values = getScaleTicks(scale);
    return values.map(function (value, index) {
      var radius = scale(value);

      if ('bandwidth' in scale) {
        radius += scale.bandwidth() / 2;
      }

      return {
        id: index,
        radius: radius
      };
    });
  }, [scale]);

  var _useMotionConfig = useMotionConfig(),
      animate = _useMotionConfig.animate,
      springConfig = _useMotionConfig.config;

  var transition = useTransition(radii, {
    keys: function keys(item) {
      return item.id;
    },
    initial: function initial(item) {
      return {
        radius: item.radius,
        startAngle: startAngle,
        endAngle: endAngle,
        opacity: 1
      };
    },
    from: function from(item) {
      return {
        radius: item.radius,
        startAngle: startAngle,
        endAngle: endAngle,
        opacity: 0
      };
    },
    enter: function enter(item) {
      return {
        radius: item.radius,
        startAngle: startAngle,
        endAngle: endAngle,
        opacity: 1
      };
    },
    update: function update(item) {
      return {
        radius: item.radius,
        startAngle: startAngle,
        endAngle: endAngle,
        opacity: 1
      };
    },
    leave: function leave(item) {
      return {
        radius: item.radius,
        startAngle: startAngle,
        endAngle: endAngle,
        opacity: 0
      };
    },
    config: springConfig,
    immediate: !animate
  });
  return jsx(Fragment, {
    children: transition(function (style, item) {
      return jsx(ArcLine, _objectSpread2(_objectSpread2({
        animated: style
      }, theme.grid.line), {}, {
        strokeOpacity: style.opacity,
        fill: "none"
      }), item.id);
    })
  });
};

var PolarGrid = function PolarGrid(_ref) {
  var center = _ref.center,
      enableRadialGrid = _ref.enableRadialGrid,
      enableCircularGrid = _ref.enableCircularGrid,
      angleScale = _ref.angleScale,
      radiusScale = _ref.radiusScale,
      startAngle = _ref.startAngle,
      endAngle = _ref.endAngle;
  var innerRadius = Math.min.apply(Math, _toConsumableArray(radiusScale.range()));
  var outerRadius = Math.max.apply(Math, _toConsumableArray(radiusScale.range()));
  return jsxs("g", {
    transform: "translate(".concat(center[0], ",").concat(center[1], ")"),
    children: [enableRadialGrid && jsx(RadialGrid, {
      scale: angleScale,
      innerRadius: innerRadius,
      outerRadius: outerRadius
    }), enableCircularGrid && jsx(CircularGrid, {
      scale: radiusScale,
      startAngle: startAngle,
      endAngle: endAngle
    })]
  });
};

var RadialAxisTick = function RadialAxisTick(_ref) {
  var label = _ref.label,
      textAnchor = _ref.textAnchor,
      animatedProps = _ref.animated;
  var theme = useTheme();
  return jsxs(animated.g, {
    opacity: animatedProps.opacity,
    transform: to([animatedProps.y, animatedProps.rotation], function (y, rotation) {
      return "translate(".concat(y, ", 0) rotate(").concat(rotation, ")");
    }),
    children: [jsx(animated.line, {
      x2: animatedProps.length,
      style: theme.axis.ticks.line
    }), jsx(animated.text, {
      dx: animatedProps.textX,
      textAnchor: textAnchor,
      dominantBaseline: "central",
      style: theme.axis.ticks.text,
      children: label
    })]
  });
};

var RadialAxis = function RadialAxis(_ref) {
  var type = _ref.type,
      center = _ref.center,
      rawAngle = _ref.angle,
      scale = _ref.scale,
      _ref$tickSize = _ref.tickSize,
      tickSize = _ref$tickSize === void 0 ? 5 : _ref$tickSize,
      _ref$tickPadding = _ref.tickPadding,
      tickPadding = _ref$tickPadding === void 0 ? 5 : _ref$tickPadding,
      _ref$tickRotation = _ref.tickRotation,
      extraRotation = _ref$tickRotation === void 0 ? 0 : _ref$tickRotation,
      _ref$tickComponent = _ref.tickComponent,
      tickComponent = _ref$tickComponent === void 0 ? RadialAxisTick : _ref$tickComponent;
  var angle = normalizeAngle(rawAngle);
  var textAnchor;
  var lineX;
  var textX;
  var tickRotation;

  if (type === 'start') {
    tickRotation = 90 + extraRotation;

    if (angle <= 90) {
      lineX = -tickSize;
      textX = lineX - tickPadding;
      textAnchor = 'end';
    } else if (angle < 270) {
      lineX = tickSize;
      textX = lineX + tickPadding;
      textAnchor = 'start';
      tickRotation -= 180;
    } else {
      lineX = -tickSize;
      textX = lineX - tickPadding;
      textAnchor = 'end';
    }
  } else {
    tickRotation = 90 + extraRotation;

    if (angle < 90) {
      lineX = tickSize;
      textX = lineX + tickPadding;
      textAnchor = 'start';
    } else if (angle < 270) {
      lineX = -tickSize;
      textX = lineX - tickPadding;
      textAnchor = 'end';
      tickRotation -= 180;
    } else {
      lineX = tickSize;
      textX = lineX + tickPadding;
      textAnchor = 'start';
    }
  }

  var ticks = useMemo(function () {
    var values = getScaleTicks(scale);
    return values.map(function (value, index) {
      var position = scale(value);

      if ('bandwidth' in scale) {
        position += scale.bandwidth() / 2;
      }

      return {
        key: index,
        label: value,
        position: position
      };
    });
  }, [scale]);

  var _useMotionConfig = useMotionConfig(),
      animate = _useMotionConfig.animate,
      springConfig = _useMotionConfig.config;

  var spring = useSpring({
    rotation: rawAngle - 90,
    immediate: !animate,
    config: springConfig
  });
  var transition = useTransition(ticks, {
    keys: function keys(tick) {
      return tick.key;
    },
    initial: function initial(tick) {
      return {
        y: tick.position,
        textX: textX,
        rotation: tickRotation,
        length: lineX,
        opacity: 1
      };
    },
    from: function from(tick) {
      return {
        y: tick.position,
        textX: textX,
        rotation: tickRotation,
        length: lineX,
        opacity: 0
      };
    },
    enter: function enter(tick) {
      return {
        y: tick.position,
        textX: textX,
        rotation: tickRotation,
        length: lineX,
        opacity: 1
      };
    },
    update: function update(tick) {
      return {
        y: tick.position,
        textX: textX,
        rotation: tickRotation,
        length: lineX,
        opacity: 1
      };
    },
    leave: function leave(tick) {
      return {
        y: tick.position,
        textX: textX,
        rotation: tickRotation,
        length: lineX,
        opacity: 0
      };
    },
    immediate: !animate,
    config: springConfig
  });
  return jsx("g", {
    transform: "translate(".concat(center[0], ", ").concat(center[1], ")"),
    children: jsx(animated.g, {
      transform: spring.rotation.to(function (value) {
        return "rotate(".concat(value, ")");
      }),
      children: transition(function (animatedProps, tick) {
        return createElement(tickComponent, {
          key: tick.key,
          label: tick.label,
          y: tick.position,
          textX: textX,
          rotation: tickRotation,
          length: lineX,
          textAnchor: textAnchor,
          animated: animatedProps
        });
      })
    })
  });
};

export { CircularAxis, PolarGrid, RadialAxis };
//# sourceMappingURL=nivo-polar-axes.es.js.map
