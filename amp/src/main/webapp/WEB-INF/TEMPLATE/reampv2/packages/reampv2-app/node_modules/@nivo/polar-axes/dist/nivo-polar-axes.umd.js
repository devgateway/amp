(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('@react-spring/web'), require('@nivo/core'), require('@nivo/scales'), require('@nivo/arcs'), require('react/jsx-runtime')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', '@react-spring/web', '@nivo/core', '@nivo/scales', '@nivo/arcs', 'react/jsx-runtime'], factory) :
  (global = global || self, factory(global.nivo = global.nivo || {}, global.React, global['@react-spring/web'], global.nivo, global.nivo, global.nivo, global['react/jsx-runtime']));
}(this, (function (exports, react, web, core, scales, arcs, jsxRuntime) { 'use strict';

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }

  var CircularAxisTick = function CircularAxisTick(_ref) {
    var label = _ref.label,
        animatedProps = _ref.animated;
    var theme = core.useTheme();
    return jsxRuntime.jsxs(web.animated.g, {
      opacity: animatedProps.opacity,
      children: [jsxRuntime.jsx(web.animated.line, {
        x1: animatedProps.x1,
        y1: animatedProps.y1,
        x2: animatedProps.x2,
        y2: animatedProps.y2,
        style: theme.axis.ticks.line
      }), jsxRuntime.jsx(web.animated.text, {
        dx: animatedProps.textX,
        dy: animatedProps.textY,
        dominantBaseline: "central",
        style: theme.axis.ticks.text,
        textAnchor: "middle",
        children: label
      })]
    });
  };

  var getLinePositions = function getLinePositions(angle, innerRadius, outerRadius) {
    var start = core.positionFromAngle(core.degreesToRadians(angle), innerRadius);
    var end = core.positionFromAngle(core.degreesToRadians(angle), outerRadius);
    return {
      x1: start.x,
      y1: start.y,
      x2: end.x,
      y2: end.y
    };
  };

  var getTextPosition = function getTextPosition(angle, radius) {
    var position = core.positionFromAngle(core.degreesToRadians(angle), radius);
    return {
      textX: position.x,
      textY: position.y
    };
  };

  var CircularAxis = function CircularAxis(_ref) {
    var type = _ref.type,
        _ref$center = _ref.center,
        center = _ref$center === void 0 ? [0, 0] : _ref$center,
        radius = _ref.radius,
        originalStartAngle = _ref.startAngle,
        originalEndAngle = _ref.endAngle,
        scale = _ref.scale,
        _ref$tickSize = _ref.tickSize,
        tickSize = _ref$tickSize === void 0 ? 5 : _ref$tickSize,
        _ref$tickPadding = _ref.tickPadding,
        tickPadding = _ref$tickPadding === void 0 ? 12 : _ref$tickPadding,
        _ref$tickComponent = _ref.tickComponent,
        tickComponent = _ref$tickComponent === void 0 ? CircularAxisTick : _ref$tickComponent;
    var startAngle = originalStartAngle - 90;
    var endAngle = originalEndAngle - 90;
    var theme = core.useTheme();

    var _useMotionConfig = core.useMotionConfig(),
        animate = _useMotionConfig.animate,
        springConfig = _useMotionConfig.config;

    var spring = web.useSpring({
      radius: radius,
      startAngle: startAngle,
      endAngle: endAngle,
      opacity: 1,
      immediate: !animate,
      config: springConfig
    });
    var ticks = react.useMemo(function () {
      var values = scales.getScaleTicks(scale);
      return values.map(function (value, index) {
        return {
          key: index,
          label: value,
          angle: scale(value) - 90
        };
      });
    }, [scale]);
    var outerRadius = type === 'inner' ? radius - tickSize : radius + tickSize;
    var textRadius = type === 'inner' ? outerRadius - tickPadding : outerRadius + tickPadding;
    var transition = web.useTransition(ticks, {
      keys: function keys(tick) {
        return tick.key;
      },
      initial: function initial(tick) {
        return _objectSpread2(_objectSpread2(_objectSpread2({}, getLinePositions(tick.angle, radius, outerRadius)), getTextPosition(tick.angle, textRadius)), {}, {
          opacity: 1
        });
      },
      from: function from(tick) {
        return _objectSpread2(_objectSpread2(_objectSpread2({}, getLinePositions(tick.angle, radius, outerRadius)), getTextPosition(tick.angle, textRadius)), {}, {
          opacity: 0
        });
      },
      enter: function enter(tick) {
        return _objectSpread2(_objectSpread2(_objectSpread2({}, getLinePositions(tick.angle, radius, outerRadius)), getTextPosition(tick.angle, textRadius)), {}, {
          opacity: 1
        });
      },
      update: function update(tick) {
        return _objectSpread2(_objectSpread2(_objectSpread2({}, getLinePositions(tick.angle, radius, outerRadius)), getTextPosition(tick.angle, textRadius)), {}, {
          opacity: 1
        });
      },
      leave: function leave(tick) {
        return _objectSpread2(_objectSpread2(_objectSpread2({}, getLinePositions(tick.angle, radius, outerRadius)), getTextPosition(tick.angle, textRadius)), {}, {
          opacity: 0
        });
      },
      immediate: !animate,
      config: springConfig
    });
    return jsxRuntime.jsxs("g", {
      transform: "translate(".concat(center[0], ", ").concat(center[1], ")"),
      children: [jsxRuntime.jsx(arcs.ArcLine, _objectSpread2(_objectSpread2({
        animated: spring
      }, theme.axis.domain.line), {}, {
        fill: "none"
      })), transition(function (animatedProps, tick) {
        return react.createElement(tickComponent, {
          key: tick.key,
          label: tick.label,
          animated: animatedProps
        });
      })]
    });
  };

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  var RadialGrid = function RadialGrid(_ref) {
    var scale = _ref.scale,
        innerRadius = _ref.innerRadius,
        outerRadius = _ref.outerRadius;
    var theme = core.useTheme();
    var angles = react.useMemo(function () {
      var values = scales.getScaleTicks(scale);
      return values.map(function (angleValue, index) {
        return {
          id: index,
          angle: scale(angleValue) - 90
        };
      });
    }, [scale]);

    var _useMotionConfig = core.useMotionConfig(),
        animate = _useMotionConfig.animate,
        springConfig = _useMotionConfig.config;

    var transition = web.useTransition(angles, {
      keys: function keys(item) {
        return item.id;
      },
      initial: function initial(item) {
        return {
          angle: item.angle,
          opacity: 1
        };
      },
      from: function from(item) {
        return {
          angle: item.angle,
          opacity: 0
        };
      },
      enter: function enter(item) {
        return {
          angle: item.angle,
          opacity: 1
        };
      },
      update: function update(item) {
        return {
          angle: item.angle,
          opacity: 1
        };
      },
      leave: function leave(item) {
        return {
          angle: item.angle,
          opacity: 0
        };
      },
      config: springConfig,
      immediate: !animate
    });
    return jsxRuntime.jsx(jsxRuntime.Fragment, {
      children: transition(function (style, angle) {
        return jsxRuntime.jsx(web.animated.g, {
          transform: style.angle.to(function (v) {
            return "rotate(".concat(v, ")");
          }),
          opacity: style.opacity,
          children: jsxRuntime.jsx("line", _objectSpread2({
            x1: innerRadius,
            x2: outerRadius
          }, theme.grid.line))
        }, angle.id);
      })
    });
  };

  var CircularGrid = function CircularGrid(_ref) {
    var scale = _ref.scale,
        originalStartAngle = _ref.startAngle,
        originalEndAngle = _ref.endAngle;
    var theme = core.useTheme();
    var startAngle = originalStartAngle - 90;
    var endAngle = originalEndAngle - 90;
    var radii = react.useMemo(function () {
      var values = scales.getScaleTicks(scale);
      return values.map(function (value, index) {
        var radius = scale(value);

        if ('bandwidth' in scale) {
          radius += scale.bandwidth() / 2;
        }

        return {
          id: index,
          radius: radius
        };
      });
    }, [scale]);

    var _useMotionConfig = core.useMotionConfig(),
        animate = _useMotionConfig.animate,
        springConfig = _useMotionConfig.config;

    var transition = web.useTransition(radii, {
      keys: function keys(item) {
        return item.id;
      },
      initial: function initial(item) {
        return {
          radius: item.radius,
          startAngle: startAngle,
          endAngle: endAngle,
          opacity: 1
        };
      },
      from: function from(item) {
        return {
          radius: item.radius,
          startAngle: startAngle,
          endAngle: endAngle,
          opacity: 0
        };
      },
      enter: function enter(item) {
        return {
          radius: item.radius,
          startAngle: startAngle,
          endAngle: endAngle,
          opacity: 1
        };
      },
      update: function update(item) {
        return {
          radius: item.radius,
          startAngle: startAngle,
          endAngle: endAngle,
          opacity: 1
        };
      },
      leave: function leave(item) {
        return {
          radius: item.radius,
          startAngle: startAngle,
          endAngle: endAngle,
          opacity: 0
        };
      },
      config: springConfig,
      immediate: !animate
    });
    return jsxRuntime.jsx(jsxRuntime.Fragment, {
      children: transition(function (style, item) {
        return jsxRuntime.jsx(arcs.ArcLine, _objectSpread2(_objectSpread2({
          animated: style
        }, theme.grid.line), {}, {
          strokeOpacity: style.opacity,
          fill: "none"
        }), item.id);
      })
    });
  };

  var PolarGrid = function PolarGrid(_ref) {
    var center = _ref.center,
        enableRadialGrid = _ref.enableRadialGrid,
        enableCircularGrid = _ref.enableCircularGrid,
        angleScale = _ref.angleScale,
        radiusScale = _ref.radiusScale,
        startAngle = _ref.startAngle,
        endAngle = _ref.endAngle;
    var innerRadius = Math.min.apply(Math, _toConsumableArray(radiusScale.range()));
    var outerRadius = Math.max.apply(Math, _toConsumableArray(radiusScale.range()));
    return jsxRuntime.jsxs("g", {
      transform: "translate(".concat(center[0], ",").concat(center[1], ")"),
      children: [enableRadialGrid && jsxRuntime.jsx(RadialGrid, {
        scale: angleScale,
        innerRadius: innerRadius,
        outerRadius: outerRadius
      }), enableCircularGrid && jsxRuntime.jsx(CircularGrid, {
        scale: radiusScale,
        startAngle: startAngle,
        endAngle: endAngle
      })]
    });
  };

  var RadialAxisTick = function RadialAxisTick(_ref) {
    var label = _ref.label,
        textAnchor = _ref.textAnchor,
        animatedProps = _ref.animated;
    var theme = core.useTheme();
    return jsxRuntime.jsxs(web.animated.g, {
      opacity: animatedProps.opacity,
      transform: web.to([animatedProps.y, animatedProps.rotation], function (y, rotation) {
        return "translate(".concat(y, ", 0) rotate(").concat(rotation, ")");
      }),
      children: [jsxRuntime.jsx(web.animated.line, {
        x2: animatedProps.length,
        style: theme.axis.ticks.line
      }), jsxRuntime.jsx(web.animated.text, {
        dx: animatedProps.textX,
        textAnchor: textAnchor,
        dominantBaseline: "central",
        style: theme.axis.ticks.text,
        children: label
      })]
    });
  };

  var RadialAxis = function RadialAxis(_ref) {
    var type = _ref.type,
        center = _ref.center,
        rawAngle = _ref.angle,
        scale = _ref.scale,
        _ref$tickSize = _ref.tickSize,
        tickSize = _ref$tickSize === void 0 ? 5 : _ref$tickSize,
        _ref$tickPadding = _ref.tickPadding,
        tickPadding = _ref$tickPadding === void 0 ? 5 : _ref$tickPadding,
        _ref$tickRotation = _ref.tickRotation,
        extraRotation = _ref$tickRotation === void 0 ? 0 : _ref$tickRotation,
        _ref$tickComponent = _ref.tickComponent,
        tickComponent = _ref$tickComponent === void 0 ? RadialAxisTick : _ref$tickComponent;
    var angle = core.normalizeAngle(rawAngle);
    var textAnchor;
    var lineX;
    var textX;
    var tickRotation;

    if (type === 'start') {
      tickRotation = 90 + extraRotation;

      if (angle <= 90) {
        lineX = -tickSize;
        textX = lineX - tickPadding;
        textAnchor = 'end';
      } else if (angle < 270) {
        lineX = tickSize;
        textX = lineX + tickPadding;
        textAnchor = 'start';
        tickRotation -= 180;
      } else {
        lineX = -tickSize;
        textX = lineX - tickPadding;
        textAnchor = 'end';
      }
    } else {
      tickRotation = 90 + extraRotation;

      if (angle < 90) {
        lineX = tickSize;
        textX = lineX + tickPadding;
        textAnchor = 'start';
      } else if (angle < 270) {
        lineX = -tickSize;
        textX = lineX - tickPadding;
        textAnchor = 'end';
        tickRotation -= 180;
      } else {
        lineX = tickSize;
        textX = lineX + tickPadding;
        textAnchor = 'start';
      }
    }

    var ticks = react.useMemo(function () {
      var values = scales.getScaleTicks(scale);
      return values.map(function (value, index) {
        var position = scale(value);

        if ('bandwidth' in scale) {
          position += scale.bandwidth() / 2;
        }

        return {
          key: index,
          label: value,
          position: position
        };
      });
    }, [scale]);

    var _useMotionConfig = core.useMotionConfig(),
        animate = _useMotionConfig.animate,
        springConfig = _useMotionConfig.config;

    var spring = web.useSpring({
      rotation: rawAngle - 90,
      immediate: !animate,
      config: springConfig
    });
    var transition = web.useTransition(ticks, {
      keys: function keys(tick) {
        return tick.key;
      },
      initial: function initial(tick) {
        return {
          y: tick.position,
          textX: textX,
          rotation: tickRotation,
          length: lineX,
          opacity: 1
        };
      },
      from: function from(tick) {
        return {
          y: tick.position,
          textX: textX,
          rotation: tickRotation,
          length: lineX,
          opacity: 0
        };
      },
      enter: function enter(tick) {
        return {
          y: tick.position,
          textX: textX,
          rotation: tickRotation,
          length: lineX,
          opacity: 1
        };
      },
      update: function update(tick) {
        return {
          y: tick.position,
          textX: textX,
          rotation: tickRotation,
          length: lineX,
          opacity: 1
        };
      },
      leave: function leave(tick) {
        return {
          y: tick.position,
          textX: textX,
          rotation: tickRotation,
          length: lineX,
          opacity: 0
        };
      },
      immediate: !animate,
      config: springConfig
    });
    return jsxRuntime.jsx("g", {
      transform: "translate(".concat(center[0], ", ").concat(center[1], ")"),
      children: jsxRuntime.jsx(web.animated.g, {
        transform: spring.rotation.to(function (value) {
          return "rotate(".concat(value, ")");
        }),
        children: transition(function (animatedProps, tick) {
          return react.createElement(tickComponent, {
            key: tick.key,
            label: tick.label,
            y: tick.position,
            textX: textX,
            rotation: tickRotation,
            length: lineX,
            textAnchor: textAnchor,
            animated: animatedProps
          });
        })
      })
    });
  };

  exports.CircularAxis = CircularAxis;
  exports.PolarGrid = PolarGrid;
  exports.RadialAxis = RadialAxis;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=nivo-polar-axes.umd.js.map
