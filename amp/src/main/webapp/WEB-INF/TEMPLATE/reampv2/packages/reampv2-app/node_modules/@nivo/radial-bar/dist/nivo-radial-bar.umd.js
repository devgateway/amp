(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@nivo/tooltip'), require('react/jsx-runtime'), require('react'), require('@nivo/core'), require('@nivo/arcs'), require('@nivo/legends'), require('@nivo/polar-axes'), require('d3-scale'), require('d3-shape'), require('@nivo/colors'), require('@nivo/scales')) :
  typeof define === 'function' && define.amd ? define(['exports', '@nivo/tooltip', 'react/jsx-runtime', 'react', '@nivo/core', '@nivo/arcs', '@nivo/legends', '@nivo/polar-axes', 'd3-scale', 'd3-shape', '@nivo/colors', '@nivo/scales'], factory) :
  (global = global || self, factory(global.nivo = global.nivo || {}, global.nivo, global['react/jsx-runtime'], global.React, global.nivo, global.nivo, global.nivo, global.nivo, global.d3, global.d3, global.nivo, global.nivo));
}(this, (function (exports, tooltip, jsxRuntime, react, core, arcs, legends, polarAxes, d3Scale, d3Shape, colors, scales) { 'use strict';

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }

  var RadialBarTooltip = function RadialBarTooltip(_ref) {
    var bar = _ref.bar;
    return jsxRuntime.jsx(tooltip.BasicTooltip, {
      enableChip: true,
      id: jsxRuntime.jsxs("span", {
        children: [bar.category, " - ", bar.groupId]
      }),
      value: bar.formattedValue,
      color: bar.color
    });
  };

  var commonDefaultProps = {
    maxValue: 'auto',
    layers: ['grid', 'tracks', 'bars', 'labels', 'legends'],
    startAngle: 0,
    endAngle: 270,
    innerRadius: 0.3,
    padding: 0.2,
    padAngle: 0,
    cornerRadius: 0,
    enableTracks: true,
    tracksColor: 'rgba(0, 0, 0, .15)',
    enableRadialGrid: true,
    enableCircularGrid: true,
    radialAxisStart: {},
    radialAxisEnd: null,
    circularAxisInner: null,
    circularAxisOuter: {},
    colors: {
      scheme: 'nivo'
    },
    borderWidth: 0,
    borderColor: {
      from: 'color',
      modifiers: [['darker', 1]]
    },
    enableLabels: false,
    label: 'formattedValue',
    labelsSkipAngle: 10,
    labelsRadiusOffset: 0.5,
    labelsTextColor: {
      theme: 'labels.text.fill'
    },
    isInteractive: true,
    tooltip: RadialBarTooltip,
    legends: [],
    animate: true,
    motionConfig: 'gentle',
    transitionMode: 'centerRadius',
    renderWrapper: true
  };
  var svgDefaultProps = _objectSpread2({}, commonDefaultProps);

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  var useRadialBar = function useRadialBar(_ref) {
    var data = _ref.data,
        _ref$maxValue = _ref.maxValue,
        maxValueDirective = _ref$maxValue === void 0 ? svgDefaultProps.maxValue : _ref$maxValue,
        valueFormat = _ref.valueFormat,
        _ref$startAngle = _ref.startAngle,
        startAngle = _ref$startAngle === void 0 ? commonDefaultProps.startAngle : _ref$startAngle,
        _ref$endAngle = _ref.endAngle,
        endAngle = _ref$endAngle === void 0 ? commonDefaultProps.endAngle : _ref$endAngle,
        _ref$innerRadiusRatio = _ref.innerRadiusRatio,
        innerRadiusRatio = _ref$innerRadiusRatio === void 0 ? commonDefaultProps.innerRadius : _ref$innerRadiusRatio,
        _ref$padding = _ref.padding,
        padding = _ref$padding === void 0 ? commonDefaultProps.padding : _ref$padding,
        _ref$padAngle = _ref.padAngle,
        padAngle = _ref$padAngle === void 0 ? commonDefaultProps.padAngle : _ref$padAngle,
        _ref$cornerRadius = _ref.cornerRadius,
        cornerRadius = _ref$cornerRadius === void 0 ? commonDefaultProps.cornerRadius : _ref$cornerRadius,
        width = _ref.width,
        height = _ref.height,
        _ref$colors = _ref.colors,
        colors$1 = _ref$colors === void 0 ? commonDefaultProps.colors : _ref$colors,
        _ref$tracksColor = _ref.tracksColor,
        tracksColor = _ref$tracksColor === void 0 ? commonDefaultProps.tracksColor : _ref$tracksColor;
    var center = react.useMemo(function () {
      return [width / 2, height / 2];
    }, [width, height]);
    var outerRadius = Math.min.apply(Math, _toConsumableArray(center));
    var innerRadius = outerRadius * Math.min(innerRadiusRatio, 1);
    var getColor = colors.useOrdinalColorScale(colors$1, 'category');

    var _useMemo = react.useMemo(function () {
      var result = {
        serieIds: [],
        categories: [],
        groups: [],
        maxValue: 0
      };
      data.forEach(function (serie) {
        result.serieIds.push(serie.id);
        var groupTotalValue = 0;
        serie.data.forEach(function (datum) {
          if (!result.categories.includes(datum.x)) {
            result.categories.push(datum.x);
          }

          groupTotalValue += datum.y;
        });
        result.groups.push({
          id: serie.id,
          total: groupTotalValue,
          data: serie.data
        });
      });

      if (maxValueDirective === 'auto') {
        result.maxValue = Math.max.apply(Math, _toConsumableArray(result.groups.map(function (group) {
          return group.total;
        })));
      } else {
        result.maxValue = maxValueDirective;
      }

      return result;
    }, [data, maxValueDirective]),
        serieIds = _useMemo.serieIds,
        categories = _useMemo.categories,
        groups = _useMemo.groups,
        maxValue = _useMemo.maxValue;

    var valueScale = react.useMemo(function () {
      return scales.castLinearScale(d3Scale.scaleLinear().domain([0, maxValue]).range([startAngle, endAngle]));
    }, [maxValue, startAngle, endAngle]);
    var radiusScale = react.useMemo(function () {
      return scales.castBandScale(d3Scale.scaleBand().domain(serieIds).range([innerRadius, outerRadius]).padding(padding));
    }, [serieIds, outerRadius, innerRadius, padding]);
    var arcGenerator = react.useMemo(function () {
      return d3Shape.arc().startAngle(function (d) {
        return d.startAngle;
      }).endAngle(function (d) {
        return d.endAngle;
      }).innerRadius(function (d) {
        return d.innerRadius;
      }).outerRadius(function (d) {
        return d.outerRadius;
      }).cornerRadius(cornerRadius).padAngle(core.degreesToRadians(padAngle));
    }, [cornerRadius, padAngle]);
    var formatValue = core.useValueFormatter(valueFormat);
    var bars = react.useMemo(function () {
      var innerBars = [];
      groups.forEach(function (group) {
        var currentValue = 0;
        var arcInnerRadius = radiusScale(group.id);
        var arcOuterRadius = arcInnerRadius + radiusScale.bandwidth();
        group.data.forEach(function (datum) {
          var stackedValue = currentValue + datum.y;
          var computedDatum = {
            id: "".concat(group.id, ".").concat(datum.x),
            data: datum,
            groupId: group.id,
            category: datum.x,
            value: datum.y,
            formattedValue: formatValue(datum.y),
            color: '',
            stackedValue: stackedValue,
            arc: {
              startAngle: core.degreesToRadians(valueScale(currentValue)),
              endAngle: core.degreesToRadians(valueScale(stackedValue)),
              innerRadius: arcInnerRadius,
              outerRadius: arcOuterRadius
            }
          };
          computedDatum.color = getColor(computedDatum);
          currentValue += datum.y;
          innerBars.push(computedDatum);
        });
      });
      return innerBars;
    }, [groups, radiusScale, valueScale, getColor, formatValue]);
    var startAngleRadians = core.degreesToRadians(startAngle);
    var endAngleRadians = core.degreesToRadians(endAngle);
    var tracks = react.useMemo(function () {
      return scales.getScaleTicks(radiusScale).map(function (value) {
        var trackRadius = radiusScale(value);
        return {
          id: value,
          color: tracksColor,
          arc: {
            startAngle: startAngleRadians,
            endAngle: endAngleRadians,
            innerRadius: trackRadius,
            outerRadius: trackRadius + radiusScale.bandwidth()
          }
        };
      });
    }, [radiusScale, startAngleRadians, endAngleRadians, tracksColor]);
    var legendData = react.useMemo(function () {
      return categories.map(function (category) {
        var barWithCategory = bars.find(function (bar) {
          return bar.category === category;
        });
        var color = barWithCategory ? barWithCategory.color : undefined;
        return {
          id: category,
          label: category,
          color: color
        };
      });
    }, [categories, bars]);
    var customLayerProps = react.useMemo(function () {
      return {
        center: center,
        outerRadius: outerRadius,
        innerRadius: innerRadius,
        bars: bars,
        arcGenerator: arcGenerator,
        radiusScale: radiusScale,
        valueScale: valueScale
      };
    }, [center, outerRadius, innerRadius, bars, arcGenerator, radiusScale, valueScale]);
    return {
      center: center,
      outerRadius: outerRadius,
      innerRadius: innerRadius,
      bars: bars,
      arcGenerator: arcGenerator,
      radiusScale: radiusScale,
      valueScale: valueScale,
      tracks: tracks,
      legendData: legendData,
      customLayerProps: customLayerProps
    };
  };

  var RadialBarArcs = function RadialBarArcs(_ref) {
    var center = _ref.center,
        bars = _ref.bars,
        borderWidth = _ref.borderWidth,
        borderColor = _ref.borderColor,
        arcGenerator = _ref.arcGenerator,
        isInteractive = _ref.isInteractive,
        tooltip$1 = _ref.tooltip,
        onClick = _ref.onClick,
        onMouseEnter = _ref.onMouseEnter,
        onMouseMove = _ref.onMouseMove,
        onMouseLeave = _ref.onMouseLeave,
        transitionMode = _ref.transitionMode;

    var _useTooltip = tooltip.useTooltip(),
        showTooltipFromEvent = _useTooltip.showTooltipFromEvent,
        hideTooltip = _useTooltip.hideTooltip;

    var handleClick = react.useCallback(function (bar, event) {
      onClick === null || onClick === void 0 ? void 0 : onClick(bar, event);
    }, [onClick]);
    var handleMouseEnter = react.useCallback(function (bar, event) {
      showTooltipFromEvent(react.createElement(tooltip$1, {
        bar: bar
      }), event);
      onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter(bar, event);
    }, [showTooltipFromEvent, tooltip$1, onMouseEnter]);
    var handleMouseMove = react.useCallback(function (bar, event) {
      showTooltipFromEvent(react.createElement(tooltip$1, {
        bar: bar
      }), event);
      onMouseMove === null || onMouseMove === void 0 ? void 0 : onMouseMove(bar, event);
    }, [showTooltipFromEvent, tooltip$1, onMouseMove]);
    var handleMouseLeave = react.useCallback(function (bar, event) {
      hideTooltip();
      onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave(bar, event);
    }, [hideTooltip, onMouseLeave]);
    return jsxRuntime.jsx(arcs.ArcsLayer, {
      center: center,
      data: bars,
      arcGenerator: arcGenerator,
      borderWidth: borderWidth,
      borderColor: borderColor,
      transitionMode: transitionMode,
      onClick: isInteractive ? handleClick : undefined,
      onMouseEnter: isInteractive ? handleMouseEnter : undefined,
      onMouseMove: isInteractive ? handleMouseMove : undefined,
      onMouseLeave: isInteractive ? handleMouseLeave : undefined
    });
  };

  var RadialBarTracks = function RadialBarTracks(_ref) {
    var center = _ref.center,
        tracks = _ref.tracks,
        arcGenerator = _ref.arcGenerator,
        transitionMode = _ref.transitionMode;
    return jsxRuntime.jsx(arcs.ArcsLayer, {
      center: center,
      data: tracks,
      arcGenerator: arcGenerator,
      borderWidth: 0,
      borderColor: "none",
      transitionMode: transitionMode
    });
  };

  var InnerRadialBar = function InnerRadialBar(_ref) {
    var data = _ref.data,
        _ref$maxValue = _ref.maxValue,
        maxValue = _ref$maxValue === void 0 ? svgDefaultProps.maxValue : _ref$maxValue,
        valueFormat = _ref.valueFormat,
        _ref$startAngle = _ref.startAngle,
        originalStartAngle = _ref$startAngle === void 0 ? svgDefaultProps.startAngle : _ref$startAngle,
        _ref$endAngle = _ref.endAngle,
        originalEndAngle = _ref$endAngle === void 0 ? svgDefaultProps.endAngle : _ref$endAngle,
        _ref$innerRadius = _ref.innerRadius,
        innerRadiusRatio = _ref$innerRadius === void 0 ? svgDefaultProps.innerRadius : _ref$innerRadius,
        _ref$padding = _ref.padding,
        padding = _ref$padding === void 0 ? svgDefaultProps.padding : _ref$padding,
        _ref$padAngle = _ref.padAngle,
        padAngle = _ref$padAngle === void 0 ? svgDefaultProps.padAngle : _ref$padAngle,
        _ref$cornerRadius = _ref.cornerRadius,
        cornerRadius = _ref$cornerRadius === void 0 ? svgDefaultProps.cornerRadius : _ref$cornerRadius,
        width = _ref.width,
        height = _ref.height,
        partialMargin = _ref.margin,
        _ref$layers = _ref.layers,
        layers = _ref$layers === void 0 ? svgDefaultProps.layers : _ref$layers,
        _ref$enableTracks = _ref.enableTracks,
        enableTracks = _ref$enableTracks === void 0 ? svgDefaultProps.enableTracks : _ref$enableTracks,
        _ref$tracksColor = _ref.tracksColor,
        tracksColor = _ref$tracksColor === void 0 ? svgDefaultProps.tracksColor : _ref$tracksColor,
        _ref$enableRadialGrid = _ref.enableRadialGrid,
        enableRadialGrid = _ref$enableRadialGrid === void 0 ? svgDefaultProps.enableRadialGrid : _ref$enableRadialGrid,
        _ref$enableCircularGr = _ref.enableCircularGrid,
        enableCircularGrid = _ref$enableCircularGr === void 0 ? svgDefaultProps.enableCircularGrid : _ref$enableCircularGr,
        _ref$radialAxisStart = _ref.radialAxisStart,
        radialAxisStart = _ref$radialAxisStart === void 0 ? svgDefaultProps.radialAxisStart : _ref$radialAxisStart,
        _ref$radialAxisEnd = _ref.radialAxisEnd,
        radialAxisEnd = _ref$radialAxisEnd === void 0 ? svgDefaultProps.radialAxisEnd : _ref$radialAxisEnd,
        _ref$circularAxisInne = _ref.circularAxisInner,
        circularAxisInner = _ref$circularAxisInne === void 0 ? svgDefaultProps.circularAxisInner : _ref$circularAxisInne,
        _ref$circularAxisOute = _ref.circularAxisOuter,
        circularAxisOuter = _ref$circularAxisOute === void 0 ? svgDefaultProps.circularAxisOuter : _ref$circularAxisOute,
        _ref$colors = _ref.colors,
        colors = _ref$colors === void 0 ? svgDefaultProps.colors : _ref$colors,
        _ref$borderWidth = _ref.borderWidth,
        borderWidth = _ref$borderWidth === void 0 ? svgDefaultProps.borderWidth : _ref$borderWidth,
        _ref$borderColor = _ref.borderColor,
        borderColor = _ref$borderColor === void 0 ? svgDefaultProps.borderColor : _ref$borderColor,
        _ref$enableLabels = _ref.enableLabels,
        enableLabels = _ref$enableLabels === void 0 ? svgDefaultProps.enableLabels : _ref$enableLabels,
        _ref$label = _ref.label,
        label = _ref$label === void 0 ? svgDefaultProps.label : _ref$label,
        _ref$labelsSkipAngle = _ref.labelsSkipAngle,
        labelsSkipAngle = _ref$labelsSkipAngle === void 0 ? svgDefaultProps.labelsSkipAngle : _ref$labelsSkipAngle,
        _ref$labelsRadiusOffs = _ref.labelsRadiusOffset,
        labelsRadiusOffset = _ref$labelsRadiusOffs === void 0 ? svgDefaultProps.labelsRadiusOffset : _ref$labelsRadiusOffs,
        _ref$labelsTextColor = _ref.labelsTextColor,
        labelsTextColor = _ref$labelsTextColor === void 0 ? svgDefaultProps.labelsTextColor : _ref$labelsTextColor,
        _ref$isInteractive = _ref.isInteractive,
        isInteractive = _ref$isInteractive === void 0 ? svgDefaultProps.isInteractive : _ref$isInteractive,
        _ref$tooltip = _ref.tooltip,
        tooltip = _ref$tooltip === void 0 ? svgDefaultProps.tooltip : _ref$tooltip,
        onClick = _ref.onClick,
        onMouseEnter = _ref.onMouseEnter,
        onMouseMove = _ref.onMouseMove,
        onMouseLeave = _ref.onMouseLeave,
        _ref$transitionMode = _ref.transitionMode,
        transitionMode = _ref$transitionMode === void 0 ? svgDefaultProps.transitionMode : _ref$transitionMode,
        _ref$legends = _ref.legends,
        legends$1 = _ref$legends === void 0 ? svgDefaultProps.legends : _ref$legends,
        role = _ref.role,
        ariaLabel = _ref.ariaLabel,
        ariaLabelledBy = _ref.ariaLabelledBy,
        ariaDescribedBy = _ref.ariaDescribedBy;

    var _useDimensions = core.useDimensions(width, height, partialMargin),
        margin = _useDimensions.margin,
        innerWidth = _useDimensions.innerWidth,
        innerHeight = _useDimensions.innerHeight,
        outerWidth = _useDimensions.outerWidth,
        outerHeight = _useDimensions.outerHeight;

    var _clampArc = core.clampArc(originalStartAngle, originalEndAngle),
        _clampArc2 = _slicedToArray(_clampArc, 2),
        startAngle = _clampArc2[0],
        endAngle = _clampArc2[1];

    var _useRadialBar = useRadialBar({
      data: data,
      maxValue: maxValue,
      valueFormat: valueFormat,
      startAngle: startAngle,
      endAngle: endAngle,
      innerRadiusRatio: innerRadiusRatio,
      padding: padding,
      padAngle: padAngle,
      cornerRadius: cornerRadius,
      width: innerWidth,
      height: innerHeight,
      colors: colors,
      tracksColor: tracksColor
    }),
        center = _useRadialBar.center,
        innerRadius = _useRadialBar.innerRadius,
        outerRadius = _useRadialBar.outerRadius,
        bars = _useRadialBar.bars,
        arcGenerator = _useRadialBar.arcGenerator,
        radiusScale = _useRadialBar.radiusScale,
        valueScale = _useRadialBar.valueScale,
        tracks = _useRadialBar.tracks,
        legendData = _useRadialBar.legendData,
        customLayerProps = _useRadialBar.customLayerProps;

    var layerById = {
      grid: null,
      tracks: null,
      bars: null,
      labels: null,
      legends: null
    };

    if (layers.includes('grid')) {
      layerById.grid = jsxRuntime.jsxs(react.Fragment, {
        children: [jsxRuntime.jsx(polarAxes.PolarGrid, {
          center: center,
          enableRadialGrid: enableRadialGrid,
          enableCircularGrid: enableCircularGrid,
          angleScale: valueScale,
          radiusScale: radiusScale,
          startAngle: startAngle,
          endAngle: endAngle
        }), radialAxisStart && jsxRuntime.jsx(polarAxes.RadialAxis, _objectSpread2({
          type: "start",
          center: center,
          angle: Math.min(startAngle, endAngle),
          scale: radiusScale
        }, radialAxisStart)), radialAxisEnd && jsxRuntime.jsx(polarAxes.RadialAxis, _objectSpread2({
          type: "end",
          center: center,
          angle: Math.max(startAngle, endAngle),
          scale: radiusScale
        }, radialAxisEnd)), circularAxisInner && jsxRuntime.jsx(polarAxes.CircularAxis, _objectSpread2({
          type: "inner",
          center: center,
          radius: innerRadius,
          startAngle: startAngle,
          endAngle: endAngle,
          scale: valueScale
        }, circularAxisInner)), circularAxisOuter && jsxRuntime.jsx(polarAxes.CircularAxis, _objectSpread2({
          type: "outer",
          center: center,
          radius: outerRadius,
          startAngle: startAngle,
          endAngle: endAngle,
          scale: valueScale
        }, circularAxisOuter))]
      }, "grid");
    }

    if (layers.includes('tracks') && enableTracks) {
      layerById.tracks = jsxRuntime.jsx(RadialBarTracks, {
        center: center,
        tracks: tracks,
        arcGenerator: arcGenerator,
        transitionMode: transitionMode
      }, "tracks");
    }

    if (layers.includes('bars')) {
      layerById.bars = jsxRuntime.jsx(RadialBarArcs, {
        center: center,
        bars: bars,
        borderWidth: borderWidth,
        borderColor: borderColor,
        arcGenerator: arcGenerator,
        isInteractive: isInteractive,
        tooltip: tooltip,
        onClick: onClick,
        onMouseEnter: onMouseEnter,
        onMouseMove: onMouseMove,
        onMouseLeave: onMouseLeave,
        transitionMode: transitionMode
      }, "bars");
    }

    if (layers.includes('labels') && enableLabels) {
      layerById.labels = jsxRuntime.jsx(arcs.ArcLabelsLayer, {
        center: center,
        data: bars,
        label: label,
        radiusOffset: labelsRadiusOffset,
        skipAngle: labelsSkipAngle,
        textColor: labelsTextColor,
        transitionMode: transitionMode
      }, "labels");
    }

    if (layers.includes('legends') && legends$1.length > 0) {
      layerById.legends = jsxRuntime.jsx(react.Fragment, {
        children: legends$1.map(function (legend, i) {
          return jsxRuntime.jsx(legends.BoxLegendSvg, _objectSpread2(_objectSpread2({}, legend), {}, {
            containerWidth: innerWidth,
            containerHeight: innerHeight,
            data: legendData
          }), i);
        })
      }, "legends");
    }

    return jsxRuntime.jsx(core.SvgWrapper, {
      width: outerWidth,
      height: outerHeight,
      margin: margin,
      role: role,
      ariaLabel: ariaLabel,
      ariaLabelledBy: ariaLabelledBy,
      ariaDescribedBy: ariaDescribedBy,
      children: layers.map(function (layer, i) {
        var _layerById$layer;

        if (typeof layer === 'function') {
          return jsxRuntime.jsx(react.Fragment, {
            children: react.createElement(layer, customLayerProps)
          }, i);
        }

        return (_layerById$layer = layerById === null || layerById === void 0 ? void 0 : layerById[layer]) !== null && _layerById$layer !== void 0 ? _layerById$layer : null;
      })
    });
  };

  var RadialBar = function RadialBar(_ref2) {
    var _ref2$isInteractive = _ref2.isInteractive,
        isInteractive = _ref2$isInteractive === void 0 ? svgDefaultProps.isInteractive : _ref2$isInteractive,
        _ref2$animate = _ref2.animate,
        animate = _ref2$animate === void 0 ? svgDefaultProps.animate : _ref2$animate,
        _ref2$motionConfig = _ref2.motionConfig,
        motionConfig = _ref2$motionConfig === void 0 ? svgDefaultProps.motionConfig : _ref2$motionConfig,
        theme = _ref2.theme,
        renderWrapper = _ref2.renderWrapper,
        otherProps = _objectWithoutProperties(_ref2, ["isInteractive", "animate", "motionConfig", "theme", "renderWrapper"]);

    return jsxRuntime.jsx(core.Container, {
      animate: animate,
      isInteractive: isInteractive,
      motionConfig: motionConfig,
      renderWrapper: renderWrapper,
      theme: theme,
      children: jsxRuntime.jsx(InnerRadialBar, _objectSpread2({
        isInteractive: isInteractive
      }, otherProps))
    });
  };

  var ResponsiveRadialBar = function ResponsiveRadialBar(props) {
    return jsxRuntime.jsx(core.ResponsiveWrapper, {
      children: function children(_ref) {
        var width = _ref.width,
            height = _ref.height;
        return jsxRuntime.jsx(RadialBar, _objectSpread2({
          width: width,
          height: height
        }, props));
      }
    });
  };

  exports.RadialBar = RadialBar;
  exports.ResponsiveRadialBar = ResponsiveRadialBar;
  exports.commonDefaultProps = commonDefaultProps;
  exports.svgDefaultProps = svgDefaultProps;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=nivo-radial-bar.umd.js.map
