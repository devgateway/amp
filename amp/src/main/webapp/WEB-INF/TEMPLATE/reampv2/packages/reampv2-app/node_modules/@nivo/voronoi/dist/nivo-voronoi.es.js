import { useMemo, Fragment, createElement, useRef, useState, useCallback } from 'react';
import { Container, useDimensions, SvgWrapper, ResponsiveWrapper, getRelativeCursor } from '@nivo/core';
import { scaleLinear } from 'd3-scale';
import { Delaunay } from 'd3-delaunay';
import { jsx, jsxs, Fragment as Fragment$1 } from 'react/jsx-runtime';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}

var defaultVoronoiProps = {
  xDomain: [0, 1],
  yDomain: [0, 1],
  layers: ['links', 'cells', 'points', 'bounds'],
  enableLinks: false,
  linkLineWidth: 1,
  linkLineColor: '#bbbbbb',
  enableCells: true,
  cellLineWidth: 2,
  cellLineColor: '#000000',
  enablePoints: true,
  pointSize: 4,
  pointColor: '#666666',
  role: 'img'
};

var getAccessor = function getAccessor(directive) {
  return typeof directive === 'function' ? directive : function (datum) {
    return datum[directive];
  };
};

var computeMeshPoints = function computeMeshPoints(_ref) {
  var points = _ref.points,
      _ref$x = _ref.x,
      x = _ref$x === void 0 ? 'x' : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === void 0 ? 'y' : _ref$y;
  var getX = getAccessor(x);
  var getY = getAccessor(y);
  return points.map(function (point) {
    return [getX(point), getY(point)];
  });
};
var computeMesh = function computeMesh(_ref2) {
  var points = _ref2.points,
      width = _ref2.width,
      height = _ref2.height,
      debug = _ref2.debug;
  var delaunay = Delaunay.from(points);
  var voronoi = debug ? delaunay.voronoi([0, 0, width, height]) : undefined;
  return {
    delaunay: delaunay,
    voronoi: voronoi
  };
};

var useVoronoiMesh = function useVoronoiMesh(_ref) {
  var points = _ref.points,
      x = _ref.x,
      y = _ref.y,
      width = _ref.width,
      height = _ref.height,
      debug = _ref.debug;
  var points2d = useMemo(function () {
    return computeMeshPoints({
      points: points,
      x: x,
      y: y
    });
  }, [points, x, y]);
  return useMemo(function () {
    return computeMesh({
      points: points2d,
      width: width,
      height: height,
      debug: debug
    });
  }, [points2d, width, height, debug]);
};
var useVoronoi = function useVoronoi(_ref2) {
  var data = _ref2.data,
      width = _ref2.width,
      height = _ref2.height,
      xDomain = _ref2.xDomain,
      yDomain = _ref2.yDomain;
  var xScale = useMemo(function () {
    return scaleLinear().domain(xDomain).range([0, width]);
  }, [xDomain, width]);
  var yScale = useMemo(function () {
    return scaleLinear().domain(yDomain).range([0, height]);
  }, [yDomain, height]);
  var points = useMemo(function () {
    return data.map(function (d) {
      return {
        x: xScale(d.x),
        y: yScale(d.y),
        data: d
      };
    });
  }, [data, xScale, yScale]);
  return useMemo(function () {
    var delaunay = Delaunay.from(points.map(function (p) {
      return [p.x, p.y];
    }));
    var voronoi = delaunay.voronoi([0, 0, width, height]);
    return {
      points: points,
      delaunay: delaunay,
      voronoi: voronoi
    };
  }, [points, width, height]);
};
var useVoronoiLayerContext = function useVoronoiLayerContext(_ref3) {
  var points = _ref3.points,
      delaunay = _ref3.delaunay,
      voronoi = _ref3.voronoi;
  return useMemo(function () {
    return {
      points: points,
      delaunay: delaunay,
      voronoi: voronoi
    };
  }, [points, delaunay, voronoi]);
};

var InnerVoronoi = function InnerVoronoi(_ref) {
  var data = _ref.data,
      width = _ref.width,
      height = _ref.height,
      partialMargin = _ref.margin,
      _ref$layers = _ref.layers,
      layers = _ref$layers === void 0 ? defaultVoronoiProps.layers : _ref$layers,
      _ref$xDomain = _ref.xDomain,
      xDomain = _ref$xDomain === void 0 ? defaultVoronoiProps.xDomain : _ref$xDomain,
      _ref$yDomain = _ref.yDomain,
      yDomain = _ref$yDomain === void 0 ? defaultVoronoiProps.yDomain : _ref$yDomain,
      _ref$enableLinks = _ref.enableLinks,
      enableLinks = _ref$enableLinks === void 0 ? defaultVoronoiProps.enableLinks : _ref$enableLinks,
      _ref$linkLineWidth = _ref.linkLineWidth,
      linkLineWidth = _ref$linkLineWidth === void 0 ? defaultVoronoiProps.linkLineWidth : _ref$linkLineWidth,
      _ref$linkLineColor = _ref.linkLineColor,
      linkLineColor = _ref$linkLineColor === void 0 ? defaultVoronoiProps.linkLineColor : _ref$linkLineColor,
      _ref$enableCells = _ref.enableCells,
      enableCells = _ref$enableCells === void 0 ? defaultVoronoiProps.enableCells : _ref$enableCells,
      _ref$cellLineWidth = _ref.cellLineWidth,
      cellLineWidth = _ref$cellLineWidth === void 0 ? defaultVoronoiProps.cellLineWidth : _ref$cellLineWidth,
      _ref$cellLineColor = _ref.cellLineColor,
      cellLineColor = _ref$cellLineColor === void 0 ? defaultVoronoiProps.cellLineColor : _ref$cellLineColor,
      _ref$enablePoints = _ref.enablePoints,
      enablePoints = _ref$enablePoints === void 0 ? defaultVoronoiProps.enableCells : _ref$enablePoints,
      _ref$pointSize = _ref.pointSize,
      pointSize = _ref$pointSize === void 0 ? defaultVoronoiProps.pointSize : _ref$pointSize,
      _ref$pointColor = _ref.pointColor,
      pointColor = _ref$pointColor === void 0 ? defaultVoronoiProps.pointColor : _ref$pointColor,
      _ref$role = _ref.role,
      role = _ref$role === void 0 ? defaultVoronoiProps.role : _ref$role;

  var _useDimensions = useDimensions(width, height, partialMargin),
      outerWidth = _useDimensions.outerWidth,
      outerHeight = _useDimensions.outerHeight,
      margin = _useDimensions.margin,
      innerWidth = _useDimensions.innerWidth,
      innerHeight = _useDimensions.innerHeight;

  var _useVoronoi = useVoronoi({
    data: data,
    width: innerWidth,
    height: innerHeight,
    xDomain: xDomain,
    yDomain: yDomain
  }),
      points = _useVoronoi.points,
      delaunay = _useVoronoi.delaunay,
      voronoi = _useVoronoi.voronoi;

  var layerById = {
    links: null,
    cells: null,
    points: null,
    bounds: null
  };

  if (enableLinks && layers.includes('links')) {
    layerById.links = jsx("path", {
      stroke: linkLineColor,
      strokeWidth: linkLineWidth,
      fill: "none",
      d: delaunay.render()
    }, "links");
  }

  if (enableCells && layers.includes('cells')) {
    layerById.cells = jsx("path", {
      d: voronoi.render(),
      fill: "none",
      stroke: cellLineColor,
      strokeWidth: cellLineWidth
    }, "cells");
  }

  if (enablePoints && layers.includes('points')) {
    layerById.points = jsx("path", {
      stroke: "none",
      fill: pointColor,
      d: delaunay.renderPoints(undefined, pointSize / 2)
    }, "points");
  }

  if (layers.includes('bounds')) {
    layerById.bounds = jsx("path", {
      fill: "none",
      stroke: cellLineColor,
      strokeWidth: cellLineWidth,
      d: voronoi.renderBounds()
    }, "bounds");
  }

  var layerContext = useVoronoiLayerContext({
    points: points,
    delaunay: delaunay,
    voronoi: voronoi
  });
  return jsx(SvgWrapper, {
    width: outerWidth,
    height: outerHeight,
    margin: margin,
    role: role,
    children: layers.map(function (layer, i) {
      if (layerById[layer] !== undefined) {
        return layerById[layer];
      }

      if (typeof layer === 'function') {
        return jsx(Fragment, {
          children: createElement(layer, layerContext)
        }, i);
      }

      return null;
    })
  });
};

var Voronoi = function Voronoi(_ref2) {
  var theme = _ref2.theme,
      otherProps = _objectWithoutProperties(_ref2, ["theme"]);

  return jsx(Container, {
    isInteractive: false,
    animate: false,
    theme: theme,
    children: jsx(InnerVoronoi, _objectSpread2({}, otherProps))
  });
};

var ResponsiveVoronoi = function ResponsiveVoronoi(props) {
  return jsx(ResponsiveWrapper, {
    children: function children(_ref) {
      var width = _ref.width,
          height = _ref.height;
      return jsx(Voronoi, _objectSpread2({
        width: width,
        height: height
      }, props));
    }
  });
};

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

var Mesh = function Mesh(_ref) {
  var nodes = _ref.nodes,
      width = _ref.width,
      height = _ref.height,
      x = _ref.x,
      y = _ref.y,
      onMouseEnter = _ref.onMouseEnter,
      onMouseMove = _ref.onMouseMove,
      onMouseLeave = _ref.onMouseLeave,
      onClick = _ref.onClick,
      debug = _ref.debug;
  var elementRef = useRef(null);

  var _useState = useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      currentIndex = _useState2[0],
      setCurrentIndex = _useState2[1];

  var _useVoronoiMesh = useVoronoiMesh({
    points: nodes,
    x: x,
    y: y,
    width: width,
    height: height,
    debug: debug
  }),
      delaunay = _useVoronoiMesh.delaunay,
      voronoi = _useVoronoiMesh.voronoi;

  var voronoiPath = useMemo(function () {
    if (debug && voronoi) {
      return voronoi.render();
    }

    return undefined;
  }, [debug, voronoi]);
  var getIndexAndNodeFromEvent = useCallback(function (event) {
    if (!elementRef.current) {
      return [null, null];
    }

    var _getRelativeCursor = getRelativeCursor(elementRef.current, event),
        _getRelativeCursor2 = _slicedToArray(_getRelativeCursor, 2),
        x = _getRelativeCursor2[0],
        y = _getRelativeCursor2[1];

    var index = delaunay.find(x, y);
    return [index, index !== undefined ? nodes[index] : null];
  }, [elementRef, delaunay]);
  var handleMouseEnter = useCallback(function (event) {
    var _getIndexAndNodeFromE = getIndexAndNodeFromEvent(event),
        _getIndexAndNodeFromE2 = _slicedToArray(_getIndexAndNodeFromE, 2),
        index = _getIndexAndNodeFromE2[0],
        node = _getIndexAndNodeFromE2[1];

    setCurrentIndex(index);

    if (node) {
      onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter(node, event);
    }
  }, [getIndexAndNodeFromEvent, setCurrentIndex, onMouseEnter]);
  var handleMouseMove = useCallback(function (event) {
    var _getIndexAndNodeFromE3 = getIndexAndNodeFromEvent(event),
        _getIndexAndNodeFromE4 = _slicedToArray(_getIndexAndNodeFromE3, 2),
        index = _getIndexAndNodeFromE4[0],
        node = _getIndexAndNodeFromE4[1];

    setCurrentIndex(index);

    if (node) {
      onMouseMove === null || onMouseMove === void 0 ? void 0 : onMouseMove(node, event);
    }
  }, [getIndexAndNodeFromEvent, setCurrentIndex, onMouseMove]);
  var handleMouseLeave = useCallback(function (event) {
    setCurrentIndex(null);

    if (onMouseLeave) {
      var previousNode = undefined;

      if (currentIndex !== null) {
        previousNode = nodes[currentIndex];
      }

      previousNode && onMouseLeave(previousNode, event);
    }
  }, [setCurrentIndex, currentIndex, onMouseLeave, nodes]);
  var handleClick = useCallback(function (event) {
    var _getIndexAndNodeFromE5 = getIndexAndNodeFromEvent(event),
        _getIndexAndNodeFromE6 = _slicedToArray(_getIndexAndNodeFromE5, 2),
        index = _getIndexAndNodeFromE6[0],
        node = _getIndexAndNodeFromE6[1];

    setCurrentIndex(index);

    if (node) {
      onClick === null || onClick === void 0 ? void 0 : onClick(node, event);
    }
  }, [getIndexAndNodeFromEvent, setCurrentIndex, onClick]);
  return jsxs("g", {
    ref: elementRef,
    children: [debug && voronoi && jsxs(Fragment$1, {
      children: [jsx("path", {
        d: voronoiPath,
        stroke: "red",
        strokeWidth: 1,
        opacity: 0.75
      }), currentIndex !== null && jsx("path", {
        fill: "pink",
        opacity: 0.35,
        d: voronoi.renderCell(currentIndex)
      })]
    }), jsx("rect", {
      width: width,
      height: height,
      fill: "red",
      opacity: 0,
      style: {
        cursor: 'auto'
      },
      onMouseEnter: handleMouseEnter,
      onMouseMove: handleMouseMove,
      onMouseLeave: handleMouseLeave,
      onClick: handleClick
    })]
  });
};

var renderVoronoiToCanvas = function renderVoronoiToCanvas(ctx, voronoi) {
  ctx.save();
  ctx.globalAlpha = 0.75;
  ctx.beginPath();
  voronoi.render(ctx);
  ctx.strokeStyle = 'red';
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.restore();
};
var renderVoronoiCellToCanvas = function renderVoronoiCellToCanvas(ctx, voronoi, index) {
  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.beginPath();
  voronoi.renderCell(index, ctx);
  ctx.fillStyle = 'red';
  ctx.fill();
  ctx.restore();
};

export { Mesh, ResponsiveVoronoi, Voronoi, computeMesh, computeMeshPoints, defaultVoronoiProps, renderVoronoiCellToCanvas, renderVoronoiToCanvas, useVoronoi, useVoronoiLayerContext, useVoronoiMesh };
//# sourceMappingURL=nivo-voronoi.es.js.map
